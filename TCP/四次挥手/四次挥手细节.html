<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCP 四次挥手交互式模拟器</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f5f7fa;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .control-panel {
            flex: 1;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .visualization {
            flex: 2;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .handshake-diagram {
            width: 100%;
            height: 400px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        .client-box, .server-box {
            position: absolute;
            width: 150px;
            height: 180px;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 10px;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .client-box {
            left: 50px;
            top: 50px;
        }
        .server-box {
            right: 50px;
            top: 50px;
        }
        .status-indicator {
            font-size: 0.9em;
            margin-top: 10px;
            padding: 5px;
            border-radius: 4px;
            background-color: #e8f4fc;
        }
        .packet {
            position: absolute;
            width: 80px;
            height: 30px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            transition: all 1.5s ease;
            z-index: 10;
        }
        .packet.fin {
            background-color: #d32f2f;
        }
        .packet.ack {
            background-color: #ffa000;
        }
        .packet.fin-ack {
            background-color: #388e3c;
        }
        .packet.lost {
            background-color: #e53935;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        .packet-info {
            position: absolute;
            width: 200px;
            padding: 5px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.7em;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            pointer-events: none;
        }
        .packet:hover .packet-info {
            opacity: 1;
        }
        .drawing-line {
            position: absolute;
            height: 2px;
            background-color: #95a5a6;
            transform-origin: left center;
            transform: scaleX(0);
            transition: transform 1.5s ease;
            z-index: 5;
        }
        .drawing-line.active {
            transform: scaleX(1);
        }
        .drawing-line.fin {
            background-color: #d32f2f;
        }
        .drawing-line.ack {
            background-color: #ffa000;
        }
        .drawing-line.fin-ack {
            background-color: #388e3c;
        }
        .drawing-line.lost {
            background-color: #e53935;
        }
        .param-group {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .param-group h3 {
            margin-top: 0;
            color: #3498db;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        input[type="range"], select {
            width: 100%;
            margin-bottom: 5px;
            padding: 5px;
        }
        .value-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #7f8c8d;
        }
        .param-description {
            font-size: 0.85em;
            color: #666;
            margin-top: 8px;
            line-height: 1.4;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.secondary {
            background-color: #95a5a6;
        }
        button.secondary:hover {
            background-color: #7f8c8d;
        }
        .step-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .concept-section {
            margin-top: 30px;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .concept-card {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .data-table th {
            background-color: #f2f2f2;
        }
        .data-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .data-table tr.highlight {
            background-color: #e8f4fc;
        }
        .data-table tr.error {
            background-color: #ffebee;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8em;
            font-weight: normal;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .error-message {
            color: #e53935;
            font-weight: bold;
            margin-top: 10px;
        }
        .warning-message {
            color: #ffa000;
            font-weight: bold;
            margin-top: 10px;
        }
        .interview-question {
            background-color: #e3f2fd;
            padding: 10px;
            border-left: 4px solid #1976d2;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <h1>TCP 四次挥手交互式模拟器</h1>
    <p>通过这个交互式工具，直观理解TCP四次挥手的过程，包括正常流程和常见异常情况。</p>
    
    <div class="container">
        <div class="control-panel">
            <h2>控制面板</h2>
            
            <div class="param-group">
                <h3>模拟参数</h3>
                
                <label for="clientLastSeq">
                    客户端最后序列号
                    <span class="tooltip">?
                        <span class="tooltiptext">客户端在连接关闭前的最后一个数据包序列号</span>
                    </span>
                </label>
                <input type="range" id="clientLastSeq" min="1000" max="50000" value="23456" step="1">
                <div class="value-display">
                    <span>1000</span>
                    <span id="clientLastSeqValue">23456</span>
                    <span>50000</span>
                </div>
                
                <label for="serverLastSeq">
                    服务端最后序列号
                    <span class="tooltip">?
                        <span class="tooltiptext">服务端在连接关闭前的最后一个数据包序列号</span>
                    </span>
                </label>
                <input type="range" id="serverLastSeq" min="1000" max="50000" value="34567" step="1">
                <div class="value-display">
                    <span>1000</span>
                    <span id="serverLastSeqValue">34567</span>
                    <span>50000</span>
                </div>
            </div>
            
            <div class="param-group">
                <h3>异常场景模拟</h3>
                
                <label for="abnormalScenario">
                    选择异常场景
                    <span class="tooltip">?
                        <span class="tooltiptext">选择要模拟的异常挥手场景</span>
                    </span>
                </label>
                <select id="abnormalScenario">
                    <option value="none">正常四次挥手</option>
                    <option value="threeWay">三次挥手</option>
                    <option value="lostFinAck">FIN-ACK丢失</option>
                    <option value="lostLastAck">最后ACK丢失</option>
                    <option value="timeWait">TIME_WAIT状态</option>
                </select>
                
                <div class="param-description">
                    注意：异常场景模拟将展示TCP协议关闭连接时的关键考虑。
                </div>
            </div>
            
            <div class="step-controls">
                <button id="startSimulation">开始模拟</button>
                <button id="stepSimulation" class="secondary">单步执行</button>
                <button id="resetSimulation" class="secondary">重置</button>
            </div>
            
            <div id="errorMessage" class="error-message"></div>
            <div id="warningMessage" class="warning-message"></div>
        </div>
        
        <div class="visualization">
            <h2>TCP挥手过程可视化</h2>
            
            <div class="handshake-diagram" id="handshakeDiagram">
                <div class="connection-line"></div>
                <div class="client-box">
                    <strong>客户端</strong>
                    <div class="status-indicator" id="clientStatus">状态: ESTABLISHED</div>
                    <div id="clientSeq">序列号: -</div>
                    <div id="clientAck">确认号: -</div>
                </div>
                <div class="server-box">
                    <strong>服务端</strong>
                    <div class="status-indicator" id="serverStatus">状态: ESTABLISHED</div>
                    <div id="serverSeq">序列号: -</div>
                    <div id="serverAck">确认号: -</div>
                </div>
            </div>
            
            <h3>挥手过程详情</h3>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>步骤</th>
                        <th>数据包</th>
                        <th>方向</th>
                        <th>序列号</th>
                        <th>确认号</th>
                        <th>状态变化</th>
                        <th>说明</th>
                    </tr>
                </thead>
                <tbody id="handshakeTableBody">
                    <!-- 数据将通过JavaScript动态填充 -->
                </tbody>
            </table>
            
            <div class="interview-question">
                <h3>面试问题：为什么需要四次挥手？</h3>
                <p>TCP是全双工协议，每个方向都需要单独关闭。四次挥手确保：</p>
                <ol>
                    <li>客户端发送FIN通知服务端要关闭连接</li>
                    <li>服务端回应ACK确认收到关闭请求</li>
                    <li>服务端发送FIN通知客户端要关闭连接</li>
                    <li>客户端回应ACK确认收到关闭请求</li>
                </ol>
            </div>
        </div>
    </div>
    
    <div class="concept-section">
        <h2>TCP挥手流程解析</h2>
        
        <div class="concept-card">
            <h3>标准四次挥手流程</h3>
            <p><strong>初始状态</strong></p>
            <ul>
                <li>客户端状态：ESTABLISHED</li>
                <li>服务端状态：ESTABLISHED</li>
                <li><em>双方已完成数据传输，准备关闭连接</em></li>
            </ul>

            <p><strong>第一步：客户端发送FIN</strong></p>
            <ul>
                <li>客户端状态：ESTABLISHED → FIN_WAIT_1</li>
                <li>服务端状态：ESTABLISHED（保持不变）</li>
                <li>数据包：FIN（seq=u）</li>
                <li><em>客户端主动关闭连接，进入FIN_WAIT_1状态</em></li>
            </ul>

            <p><strong>第二步：服务端回应ACK</strong></p>
            <ul>
                <li>服务端状态：ESTABLISHED → CLOSE_WAIT</li>
                <li>客户端状态：FIN_WAIT_1 → FIN_WAIT_2</li>
                <li>数据包：ACK（ack=u+1）</li>
                <li><em>服务端确认收到FIN，进入CLOSE_WAIT状态</em></li>
                <li><em>客户端收到ACK后进入FIN_WAIT_2状态</em></li>
            </ul>

            <p><strong>第三步：服务端发送FIN</strong></p>
            <ul>
                <li>服务端状态：CLOSE_WAIT → LAST_ACK</li>
                <li>客户端状态：FIN_WAIT_2（保持不变）</li>
                <li>数据包：FIN（seq=v, ack=u+1）</li>
                <li><em>服务端完成数据发送后发送FIN，进入LAST_ACK状态</em></li>
            </ul>

            <p><strong>第四步：客户端发送ACK</strong></p>
            <ul>
                <li>客户端状态：FIN_WAIT_2 → TIME_WAIT</li>
                <li>服务端状态：LAST_ACK → CLOSED</li>
                <li>数据包：ACK（ack=v+1）</li>
                <li><em>客户端确认收到FIN，进入TIME_WAIT状态</em></li>
                <li><em>服务端收到ACK后关闭连接</em></li>
            </ul>

            <p><strong>最终状态</strong></p>
            <ul>
                <li>客户端状态：TIME_WAIT → CLOSED（2MSL超时后）</li>
                <li>服务端状态：CLOSED</li>
                <li><em>连接完全关闭</em></li>
            </ul>
        </div>
        
        <div class="concept-card">
            <h3>三次挥手场景</h3>
            <p>当服务端的FIN和ACK合并发送时：</p>
            <ul>
                <li>客户端发送FIN → 服务端发送FIN-ACK → 客户端发送ACK</li>
                <li>减少了数据包数量，但可能导致客户端过早释放资源</li>
                <li>当服务端​​没有待发送数据​​且​​立即响应关闭请求​​时，可能将ACK和FIN合并发送：</li>
                <li>实际实现中，服务端可能延迟发送FIN，等待数据处理完成</li>
            </ul>
        </div>
        
        <div class="concept-card">
            <h3>FIN-ACK丢失</h3>
            <p>当服务端的FIN-ACK包丢失时：</p>
            <ul>
                <li>客户端会等待FIN-ACK超时（默认约60秒）</li>
                <li>客户端会重传FIN包（默认重试5次）</li>
                <li>服务端在收到重传的FIN后会再次发送FIN-ACK</li>
                <li>如果始终无法收到FIN-ACK，客户端最终会强制关闭连接</li>
            </ul>
        </div>
        
        <div class="concept-card">
            <h3>最后ACK丢失</h3>
            <p>当客户端的最后一个ACK包丢失时：</p>
            <ul>
                <li>服务端会等待ACK超时（默认约1分钟）</li>
                <li>服务端会重传FIN包（默认重试5次）</li>
                <li>客户端已经关闭连接，但服务端会保持LAST_ACK状态</li>
                <li>最终服务端会超时关闭连接</li>
            </ul>
        </div>
        
        <div class="concept-card">
            <h3>TIME_WAIT状态</h3>
            <p>主动关闭方会进入TIME_WAIT状态（2MSL时间）：</p>
            <ul>
                <li>确保最后一个ACK能到达对端</li>
                <li>让网络中旧的重复包失效</li>
                <li>MSL(Maximum Segment Lifetime)通常为30秒-2分钟</li>
                <li>面试常见问题：为什么TIME_WAIT是2MSL而不是1MSL？</li>
            </ul>
        </div>
        
        <div class="interview-question">
            <h3>面试问题：CLOSE_WAIT状态过多怎么办？</h3>
            <p>CLOSE_WAIT状态表示服务端已经收到FIN但未发送自己的FIN，常见原因：</p>
            <ol>
                <li>应用程序没有正确关闭socket</li>
                <li>服务端处理请求时间过长</li>
                <li>资源泄漏导致无法释放连接</li>
            </ol>
            <p>解决方案：检查应用程序的socket关闭逻辑，增加资源监控。</p>
        </div>
    </div>

    <script>
        // 获取DOM元素
        const clientLastSeqSlider = document.getElementById('clientLastSeq');
        const serverLastSeqSlider = document.getElementById('serverLastSeq');
        const abnormalScenarioSelect = document.getElementById('abnormalScenario');
        
        const clientLastSeqValue = document.getElementById('clientLastSeqValue');
        const serverLastSeqValue = document.getElementById('serverLastSeqValue');
        
        const startBtn = document.getElementById('startSimulation');
        const stepBtn = document.getElementById('stepSimulation');
        const resetBtn = document.getElementById('resetSimulation');
        
        const handshakeDiagram = document.getElementById('handshakeDiagram');
        const clientStatus = document.getElementById('clientStatus');
        const serverStatus = document.getElementById('serverStatus');
        const clientSeq = document.getElementById('clientSeq');
        const clientAck = document.getElementById('clientAck');
        const serverSeq = document.getElementById('serverSeq');
        const serverAck = document.getElementById('serverAck');
        
        const handshakeTableBody = document.getElementById('handshakeTableBody');
        const errorMessage = document.getElementById('errorMessage');
        const warningMessage = document.getElementById('warningMessage');
        
        // 模拟状态
        let simulationState = {
            step: 0,
            clientState: 'ESTABLISHED',
            serverState: 'ESTABLISHED',
            clientLastSeq: 23456,
            serverLastSeq: 34567,
            clientSeqNum: 0,
            serverSeqNum: 0,
            clientAckNum: 0,
            serverAckNum: 0,
            packets: [],
            drawingLines: [],
            abnormalScenario: 'none',
            simulationInterval: null,
            isPacketLost: false
        };
        
        // 更新显示的值
        function updateDisplayValues() {
            clientLastSeqValue.textContent = clientLastSeqSlider.value;
            serverLastSeqValue.textContent = serverLastSeqSlider.value;
        }
        
        // 监听滑块变化
        clientLastSeqSlider.addEventListener('input', updateDisplayValues);
        serverLastSeqSlider.addEventListener('input', updateDisplayValues);
        
        // 初始化显示值
        updateDisplayValues();
        
        // 绘制挥手过程
        function drawHandshake() {
            // 清空图表
            const existingPackets = document.querySelectorAll('.packet');
            existingPackets.forEach(packet => packet.remove());
            
            const existingLines = document.querySelectorAll('.drawing-line');
            existingLines.forEach(line => line.remove());
            
            // 更新状态显示
            clientStatus.textContent = `状态: ${simulationState.clientState}`;
            serverStatus.textContent = `状态: ${simulationState.serverState}`;
            clientSeq.textContent = `序列号: ${simulationState.clientSeqNum || '-'}`;
            clientAck.textContent = `确认号: ${simulationState.clientAckNum || '-'}`;
            serverSeq.textContent = `序列号: ${simulationState.serverSeqNum || '-'}`;
            serverAck.textContent = `确认号: ${simulationState.serverAckNum || '-'}`;
            
            // 获取客户端和服务端位置
            const clientRect = document.querySelector('.client-box').getBoundingClientRect();
            const serverRect = document.querySelector('.server-box').getBoundingClientRect();
            const diagramRect = handshakeDiagram.getBoundingClientRect();
            
            const clientCenter = {
                x: clientRect.left + clientRect.width - diagramRect.left,
                y: clientRect.top + clientRect.height/2 - diagramRect.top
            };
            
            const serverCenter = {
                x: serverRect.left - diagramRect.left,
                y: serverRect.top + serverRect.height/2 - diagramRect.top
            };
            
            // 绘制数据包和动画线条
            simulationState.packets.forEach((packet, index) => {
                const lineLength = Math.abs(serverCenter.x - clientCenter.x);
                const lineTop = clientCenter.y + (index * 40) - 15;
                
                // 创建动画线条
                const line = document.createElement('div');
                line.className = `drawing-line ${packet.type}`;
                line.style.width = `${lineLength}px`;
                line.style.top = `${lineTop}px`;
                
                if (packet.direction === 'client-to-server') {
                    line.style.left = `${clientCenter.x}px`;
                    line.style.backgroundColor = '#d32f2f';
                } else {
                    line.style.left = `${serverCenter.x - lineLength}px`;
                    line.style.backgroundColor = packet.type === 'ack' ? '#ffa000' : '#388e3c';
                }
                
                if (packet.isLost) {
                    line.classList.add('lost');
                }
                
                handshakeDiagram.appendChild(line);
                
                // 创建数据包
                const packetElement = document.createElement('div');
                packetElement.className = `packet ${packet.type} ${packet.isLost ? 'lost' : ''}`;
                packetElement.textContent = packet.label;
                
                // 添加数据包详细信息
                const packetInfo = document.createElement('div');
                packetInfo.className = 'packet-info';
                packetInfo.innerHTML = `
                    <div>seq=${packet.seq}</div>
                    <div>ack=${packet.ack}</div>
                    <div>${packet.flags}</div>
                    ${packet.isLost ? '<div style="color:red">(丢失)</div>' : ''}
                `;
                packetElement.appendChild(packetInfo);
                
                // 设置初始位置
                if (packet.direction === 'client-to-server') {
                    packetElement.style.left = `${clientCenter.x}px`;
                    packetElement.style.top = `${lineTop}px`;
                } else {
                    packetElement.style.left = `${serverCenter.x - 80}px`;
                    packetElement.style.top = `${lineTop}px`;
                }
                
                handshakeDiagram.appendChild(packetElement);
                
                // 动画效果
                setTimeout(() => {
                    line.classList.add('active');
                    
                    setTimeout(() => {
                        if (packet.direction === 'client-to-server' && !packet.isLost) {
                            packetElement.style.left = `${serverCenter.x - 80}px`;
                        } else if (packet.direction === 'server-to-client' && !packet.isLost) {
                            packetElement.style.left = `${clientCenter.x}px`;
                        }
                    }, 100);
                }, index * 500);
            });
            
            // 更新表格
            updateHandshakeTable();
        }
        
        // 更新握手表格
        function updateHandshakeTable() {
            handshakeTableBody.innerHTML = '';
            errorMessage.textContent = '';
            warningMessage.textContent = '';

            // 基础步骤定义
            const baseSteps = [
                {
                    step: 1,
                    packet: 'FIN',
                    direction: '客户端 → 服务端',
                    seq: simulationState.clientLastSeq + 1,
                    ack: 0,
                    clientState: 'FIN_WAIT_1',
                    serverState: 'ESTABLISHED',
                    description: '客户端发送FIN包，请求关闭连接'
                },
                {
                    step: 2,
                    packet: 'ACK',
                    direction: '服务端 → 客户端',
                    seq: simulationState.serverLastSeq,
                    ack: simulationState.clientLastSeq + 2,
                    clientState: 'FIN_WAIT_2',
                    serverState: 'CLOSE_WAIT',
                    description: '服务端回应ACK确认客户端的FIN'
                },
                {
                    step: 3,
                    packet: 'FIN',
                    direction: '服务端 → 客户端',
                    seq: simulationState.serverLastSeq + 1,
                    ack: simulationState.clientLastSeq + 2,
                    clientState: 'FIN_WAIT_2',
                    serverState: 'LAST_ACK',
                    description: '服务端发送FIN包，请求关闭连接'
                },
                {
                    step: 4,
                    packet: 'ACK',
                    direction: '客户端 → 服务端',
                    seq: simulationState.clientLastSeq + 2,
                    ack: simulationState.serverLastSeq + 2,
                    clientState: 'TIME_WAIT',
                    serverState: 'CLOSED',
                    description: '客户端回应ACK确认服务端的FIN'
                },
                {
                    step: 5,
                    packet: '-',
                    direction: '-',
                    seq: '-',
                    ack: '-',
                    clientState: 'CLOSED',
                    serverState: 'CLOSED',
                    description: '连接完全关闭'
                }
            ];

            // 根据当前步骤和异常场景生成展示步骤
            let showSteps = [];
            const currentStep = simulationState.step;
            const scenario = simulationState.abnormalScenario;

            // 正常四次挥手流程
            if (scenario === 'none') {
                showSteps = baseSteps.slice(0, currentStep + 1);
            } 
            // 三次挥手场景
            else if (scenario === 'threeWay') {
                if (currentStep >= 1) {
                    showSteps.push(baseSteps[0]);
                }
                if (currentStep >= 2) {
                    showSteps.push({
                        ...baseSteps[1],
                        packet: 'FIN-ACK',
                        description: '服务端合并发送FIN和ACK，减少挥手次数'
                    });
                }
                if (currentStep >= 3) {
                    showSteps.push({
                        ...baseSteps[3],
                        step: 3,
                        description: '客户端回应ACK确认服务端的FIN'
                    });
                }
                if (currentStep >= 4) {
                    showSteps.push({
                        step: 4,
                        packet: '-',
                        direction: '-',
                        seq: '-',
                        ack: '-',
                        clientState: 'TIME_WAIT',
                        serverState: 'CLOSED',
                        description: '连接关闭完成（三次挥手）'
                    });
                    warningMessage.textContent = '注意：三次挥手可能在某些实现中出现，但需要确保所有数据都已传输完成';
                }
            } 
            // FIN-ACK丢失场景
            else if (scenario === 'lostFinAck') {
                if (currentStep >= 1) {
                    showSteps.push(baseSteps[0]);
                }
                if (currentStep >= 2) {
                    showSteps.push({
                        ...baseSteps[1],
                        packet: 'ACK (丢失)',
                        description: '异常：服务端的ACK包丢失，客户端将超时重传FIN'
                    });
                }
                if (currentStep >= 3) {
                    showSteps.push({
                        step: 3,
                        packet: 'FIN (重传)',
                        direction: '客户端 → 服务端',
                        seq: simulationState.clientLastSeq + 1,
                        ack: 0,
                        clientState: 'FIN_WAIT_1',
                        serverState: 'ESTABLISHED',
                        description: '客户端超时未收到ACK，重传FIN包'
                    });
                    errorMessage.textContent = '错误：ACK包丢失，连接关闭过程受阻，客户端将重试';
                }
            } 
            // 最后ACK丢失场景
            else if (scenario === 'lostLastAck') {
                if (currentStep >= 1) {
                    showSteps.push(baseSteps[0]);
                }
                if (currentStep >= 2) {
                    showSteps.push(baseSteps[1]);
                }
                if (currentStep >= 3) {
                    showSteps.push(baseSteps[2]);
                }
                if (currentStep >= 4) {
                    showSteps.push({
                        ...baseSteps[3],
                        packet: 'ACK (丢失)',
                        description: '异常：最后的ACK包丢失，服务端将超时重传FIN'
                    });
                }
                if (currentStep >= 5) {
                    showSteps.push({
                        step: 5,
                        packet: 'FIN (重传)',
                        direction: '服务端 → 客户端',
                        seq: simulationState.serverLastSeq + 1,
                        ack: simulationState.clientLastSeq + 2,
                        clientState: 'TIME_WAIT',
                        serverState: 'LAST_ACK',
                        description: '服务端超时未收到ACK，重传FIN包'
                    });
                    warningMessage.textContent = '警告：最后ACK丢失，客户端已进入TIME_WAIT，但服务端将超时关闭连接';
                }
            }
            // TIME_WAIT状态演示
            else if (scenario === 'timeWait') {
                if (currentStep >= 1) {
                    showSteps.push(baseSteps[0]);
                }
                if (currentStep >= 2) {
                    showSteps.push(baseSteps[1]);
                }
                if (currentStep >= 3) {
                    showSteps.push(baseSteps[2]);
                }
                if (currentStep >= 4) {
                    showSteps.push(baseSteps[3]);
                }
                if (currentStep >= 5) {
                    showSteps.push({
                        ...baseSteps[4],
                        description: '客户端保持TIME_WAIT状态2MSL时间（通常1-4分钟）'
                    });
                    warningMessage.textContent = '注意：TIME_WAIT状态确保网络中所有残留包都消失，防止新连接收到旧包';
                }
            }

            // 渲染表格
            showSteps.forEach((step, index) => {
                const row = document.createElement('tr');
                
                // 标记异常步骤
                if (
                    (scenario === 'lostFinAck' && step.packet === 'ACK (丢失)') ||
                    (scenario === 'lostLastAck' && step.packet === 'ACK (丢失)') ||
                    (scenario === 'threeWay' && step.description.includes('三次挥手'))
                ) {
                    row.classList.add('error');
                }
                // 高亮当前步骤
                else if (index === currentStep - 1) {
                    row.classList.add('highlight');
                }

                row.innerHTML = `
                    <td>${step.step}</td>
                    <td>${step.packet}</td>
                    <td>${step.direction}</td>
                    <td>${step.seq}</td>
                    <td>${step.ack}</td>
                    <td>客户端: ${step.clientState}<br>服务端: ${step.serverState}</td>
                    <td>${step.description}</td>
                `;
                
                handshakeTableBody.appendChild(row);
            });
        }

        // 执行单步模拟
        function simulateStep() {
            if (simulationState.step >= 5) return;
            
            simulationState.step++;
            
            // 获取当前参数
            simulationState.clientLastSeq = parseInt(clientLastSeqSlider.value);
            simulationState.serverLastSeq = parseInt(serverLastSeqSlider.value);
            simulationState.abnormalScenario = abnormalScenarioSelect.value;
            
            // 根据步骤更新状态
            switch(simulationState.step) {
                case 1: // 第一步：客户端发送FIN
                    simulationState.clientState = 'FIN_WAIT_1';
                    simulationState.clientSeqNum = simulationState.clientLastSeq + 1;
                    
                    simulationState.packets = [{
                        type: 'fin',
                        label: 'FIN',
                        seq: simulationState.clientLastSeq + 1,
                        ack: 0,
                        direction: 'client-to-server',
                        flags: 'FIN=1',
                        isLost: false
                    }];
                    break;
                    
                case 2: // 第二步：服务端回应ACK
                    simulationState.serverState = 'CLOSE_WAIT';
                    simulationState.serverAckNum = simulationState.clientLastSeq + 2;
                    
                    // 检查是否是三次挥手场景
                    const isThreeWay = simulationState.abnormalScenario === 'threeWay';
                    const isFinAckLost = simulationState.abnormalScenario === 'lostFinAck';
                    
                    simulationState.packets.push({
                        type: isThreeWay ? 'fin-ack' : 'ack',
                        label: isFinAckLost ? 'ACK (丢失)' : (isThreeWay ? 'FIN-ACK' : 'ACK'),
                        seq: simulationState.serverLastSeq,
                        ack: simulationState.clientLastSeq + 2,
                        direction: 'server-to-client',
                        flags: isThreeWay ? 'FIN=1, ACK=1' : 'ACK=1',
                        isLost: isFinAckLost
                    });
                    
                    // 客户端状态变化（收到ACK后）
                    if (!isFinAckLost) {
                        simulationState.clientState = 'FIN_WAIT_2';
                    }
                    break;
                    
                case 3: // 第三步：服务端发送FIN（如果不是三次挥手）
                    if (simulationState.abnormalScenario !== 'threeWay') {
                        simulationState.serverState = 'LAST_ACK';
                        simulationState.serverSeqNum = simulationState.serverLastSeq + 1;
                        
                        simulationState.packets.push({
                            type: 'fin',
                            label: 'FIN',
                            seq: simulationState.serverLastSeq + 1,
                            ack: simulationState.clientLastSeq + 2,
                            direction: 'server-to-client',
                            flags: 'FIN=1',
                            isLost: false
                        });
                    }
                    break;
                    
                case 4: // 第四步：客户端发送ACK
                    simulationState.clientState = 'TIME_WAIT';
                    simulationState.clientAckNum = simulationState.serverLastSeq + 2;
                    
                    // 检查是否是最后ACK丢失场景
                    const isLastAckLost = simulationState.abnormalScenario === 'lostLastAck';
                    
                    simulationState.packets.push({
                        type: 'ack',
                        label: isLastAckLost ? 'ACK (丢失)' : 'ACK',
                        seq: simulationState.clientLastSeq + 2,
                        ack: simulationState.serverLastSeq + 2,
                        direction: 'client-to-server',
                        flags: 'ACK=1',
                        isLost: isLastAckLost
                    });
                    
                    // 服务端状态变化（收到ACK后）
                    if (!isLastAckLost) {
                        simulationState.serverState = 'CLOSED';
                    }
                    break;
                    
                case 5: // 第五步：连接完全关闭
                    if (simulationState.abnormalScenario === 'timeWait') {
                        // 保持TIME_WAIT状态
                        warningMessage.textContent = '客户端处于TIME_WAIT状态（2MSL时间），确保网络中所有残留包消失';
                    } else {
                        simulationState.clientState = 'CLOSED';
                        simulationState.serverState = 'CLOSED';
                    }
                    break;
            }
            
            drawHandshake();
        }
        
        // 开始模拟
        function startSimulation() {
            resetSimulation();
            
            simulationState.simulationInterval = setInterval(() => {
                simulateStep();
                
                if (simulationState.step >= 5) {
                    stopSimulation();
                }
            }, 1500);
        }
        
        // 停止模拟
        function stopSimulation() {
            if (simulationState.simulationInterval) {
                clearInterval(simulationState.simulationInterval);
                simulationState.simulationInterval = null;
            }
        }
        
        // 重置模拟
        function resetSimulation() {
            stopSimulation();
            
            simulationState = {
                step: 0,
                clientState: 'ESTABLISHED',
                serverState: 'ESTABLISHED',
                clientLastSeq: parseInt(clientLastSeqSlider.value),
                serverLastSeq: parseInt(serverLastSeqSlider.value),
                clientSeqNum: 0,
                serverSeqNum: 0,
                clientAckNum: 0,
                serverAckNum: 0,
                packets: [],
                drawingLines: [],
                abnormalScenario: abnormalScenarioSelect.value,
                simulationInterval: null,
                isPacketLost: false
            };
            
            drawHandshake();
        }
        
        // 事件监听
        startBtn.addEventListener('click', startSimulation);
        stepBtn.addEventListener('click', simulateStep);
        resetBtn.addEventListener('click', resetSimulation);
        
        // 初始绘制
        resetSimulation();
    </script>
</body>
</html>