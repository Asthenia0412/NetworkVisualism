<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCP Reno 拥塞控制算法模拟器</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f5f7fa;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .control-panel {
            flex: 1;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .visualization {
            flex: 2;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .param-group {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .param-group h3 {
            margin-top: 0;
            color: #3498db;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #7f8c8d;
        }
        .param-description {
            font-size: 0.85em;
            color: #666;
            margin-top: 8px;
            line-height: 1.4;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.secondary {
            background-color: #95a5a6;
        }
        button.secondary:hover {
            background-color: #7f8c8d;
        }
        canvas {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            background-color: #f8f9fa;
            margin-bottom: 20px;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.9em;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 3px;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .data-table th {
            background-color: #f2f2f2;
        }
        .data-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .concept-section {
            margin-top: 30px;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .concept-card {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
        }
        .step-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .phase-indicator {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            background-color: #e8f4fc;
            font-weight: 600;
            display: none;
        }
        .slow-start {
            border-left: 4px solid #2ecc71;
        }
        .congestion-avoidance {
            border-left: 4px solid #e67e22;
        }
        .fast-recovery {
            border-left: 4px solid #9b59b6;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8em;
            font-weight: normal;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .algorithm-comparison {
            margin-top: 20px;
            border-collapse: collapse;
            width: 100%;
        }
        .algorithm-comparison th, .algorithm-comparison td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .algorithm-comparison th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>TCP Reno 拥塞控制算法模拟器</h1>
    <p>通过这个交互式工具，您可以直观地理解TCP Reno拥塞控制算法的工作原理。调整参数并观察拥塞窗口的变化。</p>
    
    <div class="container">
        <div class="control-panel">
            <h2>控制面板</h2>
            
            <div class="param-group">
                <h3>基本参数</h3>
                
                <label for="initialWindow">
                    初始窗口大小 (MSS)
                    <span class="tooltip">?
                        <span class="tooltiptext">开始传输时的初始拥塞窗口大小，单位为MSS(最大段大小)</span>
                    </span>
                </label>
                <input type="range" id="initialWindow" min="1" max="10" value="1" step="1">
                <div class="value-display">
                    <span>1 MSS</span>
                    <span id="initialWindowValue">1 MSS</span>
                    <span>10 MSS</span>
                </div>
                <div class="param-description">
                    决定TCP连接开始时发送的数据量。较小的值可以避免突然冲击网络。
                </div>
                
                <label for="threshold">
                    初始阈值 (MSS)
                    <span class="tooltip">?
                        <span class="tooltiptext">慢启动阶段和拥塞避免阶段的分界点</span>
                    </span>
                </label>
                <input type="range" id="threshold" min="1" max="20" value="8" step="1">
                <div class="value-display">
                    <span>1 MSS</span>
                    <span id="thresholdValue">8 MSS</span>
                    <span>20 MSS</span>
                </div>
                <div class="param-description">
                    当拥塞窗口超过此值时，从指数增长(慢启动)转为线性增长(拥塞避免)。
                </div>
            </div>
            
            <div class="param-group">
                <h3>网络环境</h3>
                
                <label for="rtt">
                    往返时间 (RTT)
                    <span class="tooltip">?
                        <span class="tooltiptext">数据包从发送到收到确认所需的时间</span>
                    </span>
                </label>
                <input type="range" id="rtt" min="50" max="500" value="200" step="10">
                <div class="value-display">
                    <span>50ms</span>
                    <span id="rttValue">200ms</span>
                    <span>500ms</span>
                </div>
                <div class="param-description">
                    数据包从发送到收到确认所需的时间。影响窗口调整的频率。
                </div>
                
                <label for="lossRate">
                    丢包率 (%)
                    <span class="tooltip">?
                        <span class="tooltiptext">网络中数据包丢失的概率，模拟网络拥塞情况</span>
                    </span>
                </label>
                <input type="range" id="lossRate" min="0" max="20" value="5" step="1">
                <div class="value-display">
                    <span>0%</span>
                    <span id="lossRateValue">5%</span>
                    <span>20%</span>
                </div>
                <div class="param-description">
                    模拟网络拥塞程度。丢包会被Reno算法视为拥塞信号。
                </div>
                
                <label for="dupAckThreshold">
                    重复ACK阈值
                    <span class="tooltip">?
                        <span class="tooltiptext">触发快速重传所需的重复ACK数量</span>
                    </span>
                </label>
                <input type="range" id="dupAckThreshold" min="1" max="5" value="3" step="1">
                <div class="value-display">
                    <span>1</span>
                    <span id="dupAckThresholdValue">3</span>
                    <span>5</span>
                </div>
                <div class="param-description">
                    触发快速重传机制所需的重复ACK数量。标准Reno使用3个重复ACK。
                </div>
            </div>
            
            <div class="param-group">
                <h3>模拟控制</h3>
                
                <label for="simulationTime">
                    模拟时间 (RTT)
                    <span class="tooltip">?
                        <span class="tooltiptext">模拟运行的时长，以RTT为单位</span>
                    </span>
                </label>
                <input type="range" id="simulationTime" min="10" max="50" value="20" step="1">
                <div class="value-display">
                    <span>10 RTT</span>
                    <span id="simulationTimeValue">20 RTT</span>
                    <span>50 RTT</span>
                </div>
                
                <div class="step-controls">
                    <button id="startSimulation">开始模拟</button>
                    <button id="stepSimulation" class="secondary">单步执行</button>
                    <button id="resetSimulation" class="secondary">重置</button>
                </div>
                
                <div id="phaseIndicator" class="phase-indicator">
                    当前阶段: <span id="currentPhase">未开始</span>
                </div>
            </div>
        </div>
        
        <div class="visualization">
            <h2>拥塞窗口变化可视化</h2>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #3498db;"></div>
                    <span>拥塞窗口</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e74c3c;"></div>
                    <span>丢包事件</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e67e22; border: 1px solid #d35400;"></div>
                    <span>阈值</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #9b59b6;"></div>
                    <span>快速恢复</span>
                </div>
            </div>
            
            <canvas id="congestionGraph"></canvas>
            
            <h3>详细数据</h3>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>时间 (RTT)</th>
                        <th>窗口大小 (MSS)</th>
                        <th>阶段</th>
                        <th>事件</th>
                        <th>阈值 (MSS)</th>
                    </tr>
                </thead>
                <tbody id="dataTableBody">
                    <!-- 数据将通过JavaScript动态填充 -->
                </tbody>
            </table>
        </div>
    </div>
    
    <div class="concept-section">
        <h2>Reno算法概念解析</h2>
        
        <div class="concept-card">
            <h3>Reno算法核心改进</h3>
            <p>TCP Reno是对Tahoe算法的改进，主要引入了<strong>快速恢复(Fast Recovery)</strong>机制：</p>
            <ul>
                <li><strong>快速重传(Fast Retransmit)</strong>：收到3个重复ACK时立即重传丢失的包。</li>
                <li><strong>快速恢复(Fast Recovery)</strong>：不将窗口完全重置为1，而是减半后进入线性增长。</li>
                <li><strong>选择性确认(SACK)</strong>：可选扩展，能更精确地识别多个丢包。</li>
            </ul>
        </div>
        
        <div class="concept-card">
            <h3>Reno算法的四个阶段</h3>
            <ol>
                <li><strong>慢启动(Slow Start)</strong>：
                    <ul>
                        <li>窗口从1 MSS开始，每收到一个ACK增加1 MSS（指数增长）。</li>
                        <li>公式：<code>cwnd += 1</code>（每个ACK）</li>
                    </ul>
                </li>
                <li><strong>拥塞避免(Congestion Avoidance)</strong>：
                    <ul>
                        <li>当<code>cwnd ≥ ssthresh</code>时，转为每RTT增加1 MSS的线性增长。</li>
                        <li>公式：<code>cwnd += 1/cwnd</code>（每个ACK）</li>
                    </ul>
                </li>
                <li><strong>快速重传(Fast Retransmit)</strong>：
                    <ul>
                        <li>收到3个重复ACK时立即重传丢失的包。</li>
                        <li>将<code>ssthresh</code>设为<code>cwnd/2</code>。</li>
                    </ul>
                </li>
                <li><strong>快速恢复(Fast Recovery)</strong>：
                    <ul>
                        <li>将<code>cwnd</code>设为<code>ssthresh + 3</code>（而非Tahoe的直接重置为1）。</li>
                        <li>每收到一个重复ACK，<code>cwnd += 1</code>。</li>
                        <li>收到新数据ACK后退出快速恢复，将<code>cwnd</code>设为<code>ssthresh</code>。</li>
                    </ul>
                </li>
            </ol>
        </div>
        
        <div class="concept-card">
            <h3>Reno vs Tahoe 关键区别</h3>
            <table class="algorithm-comparison">
                <tr>
                    <th>特性</th>
                    <th>Reno</th>
                    <th>Tahoe</th>
                </tr>
                <tr>
                    <td>快速恢复</td>
                    <td>有（窗口减半）</td>
                    <td>无（窗口重置为1）</td>
                </tr>
                <tr>
                    <td>重复ACK处理</td>
                    <td>进入快速恢复阶段</td>
                    <td>直接重置为慢启动</td>
                </tr>
                <tr>
                    <td>超时处理</td>
                    <td>窗口重置为1</td>
                    <td>窗口重置为1</td>
                </tr>
                <tr>
                    <td>吞吐量</td>
                    <td>较高（恢复快）</td>
                    <td>较低（恢复慢）</td>
                </tr>
            </table>
        </div>
    </div>

    <script>
        // 获取DOM元素
        const sliders = {
            initialWindow: document.getElementById('initialWindow'),
            threshold: document.getElementById('threshold'),
            rtt: document.getElementById('rtt'),
            lossRate: document.getElementById('lossRate'),
            dupAckThreshold: document.getElementById('dupAckThreshold'),
            simulationTime: document.getElementById('simulationTime')
        };
        
        const valueDisplays = {
            initialWindow: document.getElementById('initialWindowValue'),
            threshold: document.getElementById('thresholdValue'),
            rtt: document.getElementById('rttValue'),
            lossRate: document.getElementById('lossRateValue'),
            dupAckThreshold: document.getElementById('dupAckThresholdValue'),
            simulationTime: document.getElementById('simulationTimeValue')
        };
        
        const startBtn = document.getElementById('startSimulation');
        const stepBtn = document.getElementById('stepSimulation');
        const resetBtn = document.getElementById('resetSimulation');
        const phaseIndicator = document.getElementById('phaseIndicator');
        const currentPhaseText = document.getElementById('currentPhase');
        const canvas = document.getElementById('congestionGraph');
        const ctx = canvas.getContext('2d');
        const dataTableBody = document.getElementById('dataTableBody');
        
        // 模拟状态
        let simulationState = {
            running: false,
            currentStep: 0,
            cwnd: 1,
            ssthresh: 8,
            time: 0,
            phase: 'slow-start', // 'slow-start', 'congestion-avoidance', 'fast-recovery'
            lastLossTime: -10,
            dupAckCount: 0,
            dataPoints: [],
            simulationInterval: null,
            inRecovery: false,
            recoveryStartTime: -1
        };
        
        // 设置canvas的实际尺寸
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        
        // 初始化时调整canvas尺寸
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 更新显示的值
        function updateDisplayValues() {
            for (const [key, slider] of Object.entries(sliders)) {
                if (key === 'lossRate') {
                    valueDisplays[key].textContent = `${slider.value}%`;
                } else if (key === 'rtt') {
                    valueDisplays[key].textContent = `${slider.value}ms`;
                } else if (key === 'dupAckThreshold') {
                    valueDisplays[key].textContent = slider.value;
                } else {
                    valueDisplays[key].textContent = `${slider.value} MSS`;
                }
            }
        }
        
        // 监听滑块变化
        Object.values(sliders).forEach(slider => {
            slider.addEventListener('input', updateDisplayValues);
        });
        
        // 初始化显示值
        updateDisplayValues();
        
        // 绘制图表
        function drawGraph() {
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            const simulationTime = parseInt(sliders.simulationTime.value);
            const threshold = parseInt(sliders.threshold.value);
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 计算比例
            const xStep = (width - 60) / simulationTime;
            const maxCwnd = Math.max(threshold * 1.5, ...simulationState.dataPoints.map(p => p.cwnd));
            const yScale = (height - 60) / maxCwnd;
            
            // 绘制坐标轴
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, height - 30);
            ctx.lineTo(width - 10, height - 30);
            ctx.moveTo(50, height - 30);
            ctx.lineTo(50, 20);
            ctx.stroke();
            
            // 绘制刻度
            ctx.fillStyle = '#95a5a6';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            // X轴刻度
            for (let i = 0; i <= simulationTime; i += 5) {
                const x = 50 + i * xStep;
                ctx.fillText(i, x, height - 15);
                ctx.beginPath();
                ctx.moveTo(x, height - 30);
                ctx.lineTo(x, height - 25);
                ctx.stroke();
            }
            
            // Y轴刻度
            ctx.textAlign = 'right';
            for (let i = 0; i <= maxCwnd; i += Math.ceil(maxCwnd / 5)) {
                const y = height - 30 - i * yScale;
                ctx.fillText(i, 45, y + 5);
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(45, y);
                ctx.stroke();
            }
            
            // 绘制阈值线
            ctx.strokeStyle = '#e67e22';
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            const thresholdY = height - 30 - simulationState.ssthresh * yScale;
            ctx.moveTo(50, thresholdY);
            ctx.lineTo(width - 10, thresholdY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#e67e22';
            ctx.fillText(`阈值: ${simulationState.ssthresh} MSS`, width - 20, thresholdY - 5);
            
            // 绘制数据点
            if (simulationState.dataPoints.length > 0) {
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, height - 30 - simulationState.dataPoints[0].cwnd * yScale);
                
                for (let i = 0; i < simulationState.dataPoints.length; i++) {
                    const point = simulationState.dataPoints[i];
                    const x = 50 + point.time * xStep;
                    const y = height - 30 - point.cwnd * yScale;
                    
                    if (i > 0) {
                        // 在快速恢复阶段使用紫色线条
                        if (point.phase === 'fast-recovery') {
                            ctx.stroke();
                            ctx.strokeStyle = '#9b59b6';
                            ctx.beginPath();
                            ctx.moveTo(50 + simulationState.dataPoints[i-1].time * xStep, 
                                      height - 30 - simulationState.dataPoints[i-1].cwnd * yScale);
                        }
                        ctx.lineTo(x, y);
                    }
                    
                    // 标记丢包事件
                    if (point.event === 'loss') {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        
                        ctx.fillStyle = '#e74c3c';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#3498db';
                    }
                    
                    // 恢复蓝色线条
                    if (point.event === 'recovery-end') {
                        ctx.stroke();
                        ctx.strokeStyle = '#3498db';
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // 绘制当前点
                if (simulationState.currentStep > 0 && simulationState.currentStep <= simulationState.dataPoints.length) {
                    const currentPoint = simulationState.dataPoints[simulationState.currentStep - 1];
                    const x = 50 + currentPoint.time * xStep;
                    const y = height - 30 - currentPoint.cwnd * yScale;
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // 更新数据表格
        function updateDataTable() {
            dataTableBody.innerHTML = '';
            
            for (let i = 0; i < simulationState.dataPoints.length; i++) {
                const point = simulationState.dataPoints[i];
                const row = document.createElement('tr');
                
                if (i === simulationState.currentStep - 1) {
                    row.style.backgroundColor = '#e8f4fc';
                }
                
                // 根据阶段设置行背景色
                if (point.phase === 'slow-start') {
                    row.style.borderLeft = '4px solid #2ecc71';
                } else if (point.phase === 'congestion-avoidance') {
                    row.style.borderLeft = '4px solid #e67e22';
                } else if (point.phase === 'fast-recovery') {
                    row.style.borderLeft = '4px solid #9b59b6';
                }
                
                row.innerHTML = `
                    <td>${point.time}</td>
                    <td>${point.cwnd.toFixed(2)}</td>
                    <td>${
                        point.phase === 'slow-start' ? '慢启动' : 
                        point.phase === 'congestion-avoidance' ? '拥塞避免' : '快速恢复'
                    }</td>
                    <td>${point.event || '-'}</td>
                    <td>${point.ssthresh}</td>
                `;
                
                dataTableBody.appendChild(row);
            }
        }
        
        // 执行单步模拟
        function simulateStep() {
            if (simulationState.time >= parseInt(sliders.simulationTime.value)) {
                stopSimulation();
                return;
            }
            
            const lossRate = parseInt(sliders.lossRate.value) / 100;
            const dupAckThreshold = parseInt(sliders.dupAckThreshold.value);
            
            // 记录当前状态
            const currentDataPoint = {
                time: simulationState.time,
                cwnd: simulationState.cwnd,
                ssthresh: simulationState.ssthresh,
                phase: simulationState.phase,
                event: null
            };
            
            // 检查是否发生丢包
            if (Math.random() < lossRate && simulationState.time - simulationState.lastLossTime > 1) {
                // 随机决定是超时还是重复ACK
                const isTimeout = Math.random() > 0.5;
                
                if (isTimeout) {
                    // 超时处理（与Tahoe相同）
                    simulationState.ssthresh = Math.max(2, Math.floor(simulationState.cwnd / 2));
                    simulationState.cwnd = 1;
                    simulationState.phase = 'slow-start';
                    simulationState.dupAckCount = 0;
                    simulationState.inRecovery = false;
                    
                    currentDataPoint.event = '超时丢包';
                } else {
                    // 重复ACK处理
                    simulationState.dupAckCount++;
                    
                    if (simulationState.dupAckCount >= dupAckThreshold && !simulationState.inRecovery) {
                        // 进入快速重传和快速恢复
                        simulationState.ssthresh = Math.max(2, Math.floor(simulationState.cwnd / 2));
                        simulationState.cwnd = simulationState.ssthresh + 3; // Reno的快速恢复
                        simulationState.phase = 'fast-recovery';
                        simulationState.inRecovery = true;
                        simulationState.recoveryStartTime = simulationState.time;
                        
                        currentDataPoint.event = '重复ACK丢包';
                    } else {
                        // 未达到重复ACK阈值，继续正常处理
                        currentDataPoint.event = '重复ACK(' + simulationState.dupAckCount + ')';
                    }
                }
                
                simulationState.lastLossTime = simulationState.time;
                currentDataPoint.cwnd = simulationState.cwnd;
            } else if (simulationState.inRecovery) {
                // 快速恢复阶段处理
                if (simulationState.time - simulationState.recoveryStartTime > 1) {
                    // 假设收到新数据的ACK，退出快速恢复
                    simulationState.cwnd = simulationState.ssthresh;
                    simulationState.phase = 'congestion-avoidance';
                    simulationState.inRecovery = false;
                    simulationState.dupAckCount = 0;
                    
                    currentDataPoint.event = '恢复结束';
                } else {
                    // 快速恢复阶段每RTT增加窗口
                    simulationState.cwnd += 1;
                    currentDataPoint.phase = 'fast-recovery';
                }
            } else {
                // 正常窗口增长
                simulationState.dupAckCount = 0;
                
                if (simulationState.phase === 'slow-start') {
                    simulationState.cwnd += 1; // 慢启动指数增长
                    if (simulationState.cwnd >= simulationState.ssthresh) {
                        simulationState.phase = 'congestion-avoidance';
                    }
                } else {
                    simulationState.cwnd += 1 / simulationState.cwnd; // 拥塞避免线性增长
                }
            }
            
            simulationState.dataPoints.push(currentDataPoint);
            simulationState.time += 1;
            simulationState.currentStep = simulationState.dataPoints.length;
            
            // 更新阶段指示器
            updatePhaseIndicator();
            
            // 更新视图
            drawGraph();
            updateDataTable();
            
            // 自动滚动表格到最后一行
            if (simulationState.running) {
                dataTableBody.lastElementChild?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        // 更新阶段指示器
        function updatePhaseIndicator() {
            if (simulationState.dataPoints.length === 0) {
                phaseIndicator.style.display = 'none';
                return;
            }
            
            const currentPoint = simulationState.dataPoints[simulationState.currentStep - 1];
            
            phaseIndicator.style.display = 'block';
            phaseIndicator.className = 'phase-indicator';
            
            if (currentPoint.event === '超时丢包' || currentPoint.event === '重复ACK丢包') {
                currentPhaseText.textContent = '快速重传';
                phaseIndicator.classList.add('fast-recovery');
            } else if (currentPoint.phase === 'slow-start') {
                currentPhaseText.textContent = '慢启动';
                phaseIndicator.classList.add('slow-start');
            } else if (currentPoint.phase === 'fast-recovery') {
                currentPhaseText.textContent = '快速恢复';
                phaseIndicator.classList.add('fast-recovery');
            } else {
                currentPhaseText.textContent = '拥塞避免';
                phaseIndicator.classList.add('congestion-avoidance');
            }
        }
        
        // 开始模拟
        function startSimulation() {
            if (simulationState.running) return;
            
            resetSimulation();
            simulationState.running = true;
            
            simulationState.simulationInterval = setInterval(() => {
                simulateStep();
                
                if (simulationState.time >= parseInt(sliders.simulationTime.value)) {
                    stopSimulation();
                }
            }, 1000);
        }
        
        // 停止模拟
        function stopSimulation() {
            if (simulationState.simulationInterval) {
                clearInterval(simulationState.simulationInterval);
                simulationState.simulationInterval = null;
            }
            simulationState.running = false;
        }
        
        // 重置模拟
        function resetSimulation() {
            stopSimulation();
            
            simulationState = {
                running: false,
                currentStep: 0,
                cwnd: parseInt(sliders.initialWindow.value),
                ssthresh: parseInt(sliders.threshold.value),
                time: 0,
                phase: 'slow-start',
                lastLossTime: -10,
                dupAckCount: 0,
                dataPoints: [],
                simulationInterval: null,
                inRecovery: false,
                recoveryStartTime: -1
            };
            
            drawGraph();
            updateDataTable();
            updatePhaseIndicator();
        }
        
        // 事件监听
        startBtn.addEventListener('click', startSimulation);
        stepBtn.addEventListener('click', simulateStep);
        resetBtn.addEventListener('click', resetSimulation);
        
        // 初始绘制
        resetSimulation();
    </script>
</body>
</html>