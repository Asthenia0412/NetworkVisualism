<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tahoe 拥塞控制算法交互学习</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f5f7fa;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .control-panel {
            flex: 1;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .visualization {
            flex: 2;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .param-group {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .param-group h3 {
            margin-top: 0;
            color: #3498db;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .value-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #7f8c8d;
        }
        .param-description {
            font-size: 0.85em;
            color: #666;
            margin-top: 8px;
            line-height: 1.4;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.secondary {
            background-color: #95a5a6;
        }
        button.secondary:hover {
            background-color: #7f8c8d;
        }
        canvas {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            background-color: #f8f9fa;
            margin-bottom: 20px;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.9em;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 3px;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .data-table th {
            background-color: #f2f2f2;
        }
        .data-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .concept-section {
            margin-top: 30px;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .concept-card {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
        }
        .step-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .phase-indicator {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            background-color: #e8f4fc;
            font-weight: 600;
            display: none;
        }
        .slow-start {
            border-left: 4px solid #2ecc71;
        }
        .congestion-avoidance {
            border-left: 4px solid #e67e22;
        }
        .fast-retransmit {
            border-left: 4px solid #e74c3c;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8em;
            font-weight: normal;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <h1>Tahoe 拥塞控制算法交互学习</h1>
    <p>通过这个交互式工具，您可以直观地理解TCP Tahoe拥塞控制算法的工作原理。调整参数并观察拥塞窗口的变化。</p>
    
    <div class="container">
        <div class="control-panel">
            <h2>控制面板</h2>
            
            <div class="param-group">
                <h3>基本参数</h3>
                
                <label for="initialWindow">
                    初始窗口大小 (MSS)
                    <span class="tooltip">?
                        <span class="tooltiptext">开始传输时的初始拥塞窗口大小，单位为MSS(最大段大小)</span>
                    </span>
                </label>
                <input type="range" id="initialWindow" min="1" max="10" value="1" step="1">
                <div class="value-display">
                    <span>1 MSS</span>
                    <span id="initialWindowValue">1 MSS</span>
                    <span>10 MSS</span>
                </div>
                <div class="param-description">
                    决定TCP连接开始时发送的数据量。较小的值可以避免突然冲击网络。
                </div>
                
                <label for="threshold">
                    初始阈值 (MSS)
                    <span class="tooltip">?
                        <span class="tooltiptext">慢启动阶段和拥塞避免阶段的分界点</span>
                    </span>
                </label>
                <input type="range" id="threshold" min="1" max="20" value="8" step="1">
                <div class="value-display">
                    <span>1 MSS</span>
                    <span id="thresholdValue">8 MSS</span>
                    <span>20 MSS</span>
                </div>
                <div class="param-description">
                    当拥塞窗口超过此值时，从指数增长(慢启动)转为线性增长(拥塞避免)。
                </div>
            </div>
            
            <div class="param-group">
                <h3>网络环境</h3>
                
                <label for="rtt">
                    往返时间 (RTT)
                    <span class="tooltip">?
                        <span class="tooltiptext">数据包从发送到收到确认所需的时间</span>
                    </span>
                </label>
                <input type="range" id="rtt" min="50" max="500" value="200" step="10">
                <div class="value-display">
                    <span>50ms</span>
                    <span id="rttValue">200ms</span>
                    <span>500ms</span>
                </div>
                <div class="param-description">
                    数据包从发送到收到确认所需的时间。影响窗口调整的频率。
                </div>
                
                <label for="lossRate">
                    丢包率 (%)
                    <span class="tooltip">?
                        <span class="tooltiptext">网络中数据包丢失的概率，模拟网络拥塞情况</span>
                    </span>
                </label>
                <input type="range" id="lossRate" min="0" max="20" value="5" step="1">
                <div class="value-display">
                    <span>0%</span>
                    <span id="lossRateValue">5%</span>
                    <span>20%</span>
                </div>
                <div class="param-description">
                    模拟网络拥塞程度。丢包会被Tahoe算法视为拥塞信号。
                </div>
            </div>
            
            <div class="param-group">
                <h3>模拟控制</h3>
                
                <label for="simulationTime">
                    模拟时间 (RTT)
                    <span class="tooltip">?
                        <span class="tooltiptext">模拟运行的时长，以RTT为单位</span>
                    </span>
                </label>
                <input type="range" id="simulationTime" min="10" max="50" value="20" step="1">
                <div class="value-display">
                    <span>10 RTT</span>
                    <span id="simulationTimeValue">20 RTT</span>
                    <span>50 RTT</span>
                </div>
                
                <div class="step-controls">
                    <button id="startSimulation">开始模拟</button>
                    <button id="stepSimulation" class="secondary">单步执行</button>
                    <button id="resetSimulation" class="secondary">重置</button>
                </div>
                
                <div id="phaseIndicator" class="phase-indicator">
                    当前阶段: <span id="currentPhase">未开始</span>
                </div>
            </div>
        </div>
        
        <div class="visualization">
            <h2>拥塞窗口变化可视化</h2>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #3498db;"></div>
                    <span>拥塞窗口</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e74c3c;"></div>
                    <span>丢包事件</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e67e22; border: 1px solid #d35400;"></div>
                    <span>阈值</span>
                </div>
            </div>
            
            <canvas id="congestionGraph"></canvas>
            
            <h3>详细数据</h3>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>时间 (RTT)</th>
                        <th>窗口大小 (MSS)</th>
                        <th>阶段</th>
                        <th>事件</th>
                        <th>阈值 (MSS)</th>
                    </tr>
                </thead>
                <tbody id="dataTableBody">
                    <!-- 数据将通过JavaScript动态填充 -->
                </tbody>
            </table>
        </div>
    </div>
    
<div class="concept-section">
    <h2>Tahoe算法概念解析</h2>
    
    <div class="concept-card">
        <h3>什么是拥塞控制？</h3>
        <p>拥塞控制是TCP协议中的一种机制，用于防止网络因过多的数据包而变得拥塞。当太多设备同时发送数据时，网络中的路由器可能会因为缓冲区满而丢弃数据包，拥塞控制算法通过调整发送速率来避免这种情况。</p>
        <p><strong>关键修正说明：</strong></p>
        <ul>
            <li><strong>MSS（最大段大小）</strong>是TCP连接建立时协商的固定值，表示单个数据段的最大载荷（如1460字节），<u>不会</u>因拥塞事件改变。</li>
            <li>动态调整的是<strong>拥塞窗口（cwnd）</strong>和<strong>阈值（ssthresh）</strong>：
                <ul>
                    <li>发生丢包时，<code>ssthresh = max(cwnd/2, 2)</code></li>
                    <li><code>cwnd</code>重置为1 MSS（Tahoe的保守策略）</li>
                </ul>
            </li>
        </ul>
    </div>
    
    <div class="concept-card">
        <h3>Tahoe算法的三个阶段</h3>
        <ol>
            <li><strong>慢启动(Slow Start)</strong>：
                <ul>
                    <li>窗口从1 MSS开始，<u>每收到一个ACK</u>增加1 MSS（指数增长）。</li>
                    <li>增长公式：<code>cwnd += 1</code>（每个ACK）</li>
                </ul>
            </li>
            <li><strong>拥塞避免(Congestion Avoidance)</strong>：
                <ul>
                    <li>当<code>cwnd ≥ ssthresh</code>时，转为<u>每RTT增加1 MSS</u>的线性增长。</li>
                    <li>增长公式：<code>cwnd += 1/cwnd</code>（每个ACK）</li>
                </ul>
            </li>
            <li><strong>快速重传(Fast Retransmit)</strong>：
                <ul>
                    <li>当收到3个重复ACK时，立即重传丢失的包。</li>
                    <li>Tahoe会直接将<code>cwnd</code>重置为1并重新慢启动。</li>
                </ul>
            </li>
        </ol>
    </div>
    
    <div class="concept-card">
        <h3>关键参数解释</h3>
        <ul>
            <li><strong>拥塞窗口（cwnd）</strong>：发送方在未收到确认前可以发送的最大数据量（单位为MSS）。</li>
            <li><strong>阈值（ssthresh）</strong>：慢启动和拥塞避免的分界点，动态调整（初始值通常为接收方窗口大小或系统默认值）。</li>
            <li><strong>RTT</strong>：数据包往返时间，决定ACK到达的频率，从而影响窗口调整速度。</li>
            <li><strong>MSS</strong>：最大段大小，<u>固定值</u>，取决于链路MTU（如以太网中通常为1460字节）。</li>
        </ul>
    </div>
</div>

    <script>
        // 获取DOM元素
        const sliders = {
            initialWindow: document.getElementById('initialWindow'),
            threshold: document.getElementById('threshold'),
            rtt: document.getElementById('rtt'),
            lossRate: document.getElementById('lossRate'),
            simulationTime: document.getElementById('simulationTime')
        };
        
        const valueDisplays = {
            initialWindow: document.getElementById('initialWindowValue'),
            threshold: document.getElementById('thresholdValue'),
            rtt: document.getElementById('rttValue'),
            lossRate: document.getElementById('lossRateValue'),
            simulationTime: document.getElementById('simulationTimeValue')
        };
        
        const startBtn = document.getElementById('startSimulation');
        const stepBtn = document.getElementById('stepSimulation');
        const resetBtn = document.getElementById('resetSimulation');
        const phaseIndicator = document.getElementById('phaseIndicator');
        const currentPhaseText = document.getElementById('currentPhase');
        const canvas = document.getElementById('congestionGraph');
        const ctx = canvas.getContext('2d');
        const dataTableBody = document.getElementById('dataTableBody');
        
        // 模拟状态
        let simulationState = {
            running: false,
            currentStep: 0,
            cwnd: 1,
            ssthresh: 8,
            time: 0,
            inSlowStart: true,
            lastLossTime: -10,
            dataPoints: [],
            simulationInterval: null
        };
        
        // 设置canvas的实际尺寸
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        
        // 初始化时调整canvas尺寸
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 更新显示的值
        function updateDisplayValues() {
            for (const [key, slider] of Object.entries(sliders)) {
                if (key === 'lossRate') {
                    valueDisplays[key].textContent = `${slider.value}%`;
                } else if (key === 'rtt') {
                    valueDisplays[key].textContent = `${slider.value}ms`;
                } else {
                    valueDisplays[key].textContent = `${slider.value} MSS`;
                }
            }
        }
        
        // 监听滑块变化
        Object.values(sliders).forEach(slider => {
            slider.addEventListener('input', updateDisplayValues);
        });
        
        // 初始化显示值
        updateDisplayValues();
        
        // 绘制图表
        function drawGraph() {
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            const simulationTime = parseInt(sliders.simulationTime.value);
            const threshold = parseInt(sliders.threshold.value);
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 计算比例
            const xStep = (width - 60) / simulationTime;
            const maxCwnd = Math.max(threshold * 1.5, ...simulationState.dataPoints.map(p => p.cwnd));
            const yScale = (height - 60) / maxCwnd;
            
            // 绘制坐标轴
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, height - 30);
            ctx.lineTo(width - 10, height - 30);
            ctx.moveTo(50, height - 30);
            ctx.lineTo(50, 20);
            ctx.stroke();
            
            // 绘制刻度
            ctx.fillStyle = '#95a5a6';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            // X轴刻度
            for (let i = 0; i <= simulationTime; i += 5) {
                const x = 50 + i * xStep;
                ctx.fillText(i, x, height - 15);
                ctx.beginPath();
                ctx.moveTo(x, height - 30);
                ctx.lineTo(x, height - 25);
                ctx.stroke();
            }
            
            // Y轴刻度
            ctx.textAlign = 'right';
            for (let i = 0; i <= maxCwnd; i += Math.ceil(maxCwnd / 5)) {
                const y = height - 30 - i * yScale;
                ctx.fillText(i, 45, y + 5);
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(45, y);
                ctx.stroke();
            }
            
            // 绘制阈值线
            ctx.strokeStyle = '#e67e22';
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            const thresholdY = height - 30 - threshold * yScale;
            ctx.moveTo(50, thresholdY);
            ctx.lineTo(width - 10, thresholdY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#e67e22';
            ctx.fillText(`阈值: ${threshold} MSS`, width - 20, thresholdY - 5);
            
            // 绘制数据点
            if (simulationState.dataPoints.length > 0) {
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, height - 30 - simulationState.dataPoints[0].cwnd * yScale);
                
                for (let i = 0; i < simulationState.dataPoints.length; i++) {
                    const point = simulationState.dataPoints[i];
                    const x = 50 + point.time * xStep;
                    const y = height - 30 - point.cwnd * yScale;
                    
                    if (i > 0) {
                        ctx.lineTo(x, y);
                    }
                    
                    // 标记丢包事件
                    if (point.event === 'loss') {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        
                        ctx.fillStyle = '#e74c3c';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#3498db';
                    }
                }
                
                ctx.stroke();
                
                // 绘制当前点
                if (simulationState.currentStep > 0 && simulationState.currentStep <= simulationState.dataPoints.length) {
                    const currentPoint = simulationState.dataPoints[simulationState.currentStep - 1];
                    const x = 50 + currentPoint.time * xStep;
                    const y = height - 30 - currentPoint.cwnd * yScale;
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // 更新数据表格
        function updateDataTable() {
            dataTableBody.innerHTML = '';
            
            for (let i = 0; i < simulationState.dataPoints.length; i++) {
                const point = simulationState.dataPoints[i];
                const row = document.createElement('tr');
                
                if (i === simulationState.currentStep - 1) {
                    row.style.backgroundColor = '#e8f4fc';
                }
                
                row.innerHTML = `
                    <td>${point.time}</td>
                    <td>${point.cwnd.toFixed(2)}</td>
                    <td>${point.inSlowStart ? '慢启动' : '拥塞避免'}</td>
                    <td>${point.event || '-'}</td>
                    <td>${point.ssthresh}</td>
                `;
                
                dataTableBody.appendChild(row);
            }
        }
        
        // 执行单步模拟
        function simulateStep() {
            if (simulationState.time >= parseInt(sliders.simulationTime.value)) {
                stopSimulation();
                return;
            }
            
            const lossRate = parseInt(sliders.lossRate.value) / 100;
            
            // 记录当前状态
            const currentDataPoint = {
                time: simulationState.time,
                cwnd: simulationState.cwnd,
                inSlowStart: simulationState.inSlowStart,
                ssthresh: simulationState.ssthresh,
                event: null
            };
            
            // 检查是否发生丢包
            if (Math.random() < lossRate && simulationState.time - simulationState.lastLossTime > 1) {
                // Tahoe对任何丢包都重置窗口
                simulationState.ssthresh = Math.max(1, Math.floor(simulationState.cwnd / 2));
                simulationState.cwnd = 1;
                simulationState.inSlowStart = true;
                simulationState.lastLossTime = simulationState.time;
                
                currentDataPoint.event = '丢包';
                currentDataPoint.cwnd = simulationState.cwnd;
            }
            
            // 更新窗口大小
            if (simulationState.inSlowStart) {
                simulationState.cwnd += 1; // 慢启动阶段指数增长
                if (simulationState.cwnd >= simulationState.ssthresh) {
                    simulationState.inSlowStart = false;
                }
            } else {
                simulationState.cwnd += 1 / simulationState.cwnd; // 拥塞避免阶段线性增长
            }
            
            simulationState.dataPoints.push(currentDataPoint);
            simulationState.time += 1;
            simulationState.currentStep = simulationState.dataPoints.length;
            
            // 更新阶段指示器
            updatePhaseIndicator();
            
            // 更新视图
            drawGraph();
            updateDataTable();
            
            // 自动滚动表格到最后一行
            if (simulationState.running) {
                dataTableBody.lastElementChild?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        // 更新阶段指示器
        function updatePhaseIndicator() {
            if (simulationState.dataPoints.length === 0) {
                phaseIndicator.style.display = 'none';
                return;
            }
            
            const currentPoint = simulationState.dataPoints[simulationState.currentStep - 1];
            
            phaseIndicator.style.display = 'block';
            phaseIndicator.className = 'phase-indicator';
            
            if (currentPoint.event === '丢包') {
                currentPhaseText.textContent = '快速重传';
                phaseIndicator.classList.add('fast-retransmit');
            } else if (currentPoint.inSlowStart) {
                currentPhaseText.textContent = '慢启动';
                phaseIndicator.classList.add('slow-start');
            } else {
                currentPhaseText.textContent = '拥塞避免';
                phaseIndicator.classList.add('congestion-avoidance');
            }
        }
        
        // 开始模拟
        function startSimulation() {
            if (simulationState.running) return;
            
            resetSimulation();
            simulationState.running = true;
            
            simulationState.simulationInterval = setInterval(() => {
                simulateStep();
                
                if (simulationState.time >= parseInt(sliders.simulationTime.value)) {
                    stopSimulation();
                }
            }, 1000);
        }
        
        // 停止模拟
        function stopSimulation() {
            if (simulationState.simulationInterval) {
                clearInterval(simulationState.simulationInterval);
                simulationState.simulationInterval = null;
            }
            simulationState.running = false;
        }
        
        // 重置模拟
        function resetSimulation() {
            stopSimulation();
            
            simulationState = {
                running: false,
                currentStep: 0,
                cwnd: parseInt(sliders.initialWindow.value),
                ssthresh: parseInt(sliders.threshold.value),
                time: 0,
                inSlowStart: true,
                lastLossTime: -10,
                dataPoints: [],
                simulationInterval: null
            };
            
            drawGraph();
            updateDataTable();
            phaseIndicator.style.display = 'none';
        }
        
        // 事件监听
        startBtn.addEventListener('click', startSimulation);
        stepBtn.addEventListener('click', simulateStep);
        resetBtn.addEventListener('click', resetSimulation);
        
        // 初始绘制
        resetSimulation();
    </script>
</body>
</html>