<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCP 三次握手交互式模拟器（含异常场景）</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f5f7fa;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .control-panel {
            flex: 1;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .visualization {
            flex: 2;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .handshake-diagram {
            width: 100%;
            height: 400px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        .client-box, .server-box {
            position: absolute;
            width: 150px;
            height: 180px;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 10px;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .client-box {
            left: 50px;
            top: 50px;
        }
        .server-box {
            right: 50px;
            top: 50px;
        }
        .status-indicator {
            font-size: 0.9em;
            margin-top: 10px;
            padding: 5px;
            border-radius: 4px;
            background-color: #e8f4fc;
        }
        .connection-line {
            position: absolute;
            height: 2px;
            background-color: #95a5a6;
            left: 200px;
            right: 200px;
            top: 120px;
            opacity: 0.3;
        }
        .packet {
            position: absolute;
            width: 80px;
            height: 30px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            transition: all 1.5s ease;
            z-index: 10;
        }
        .packet.syn {
            background-color: #1976d2;
        }
        .packet.syn-ack {
            background-color: #388e3c;
        }
        .packet.ack {
            background-color: #ffa000;
        }
        .packet.lost {
            background-color: #e53935;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        .packet-info {
            position: absolute;
            width: 200px;
            padding: 5px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.7em;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            pointer-events: none;
        }
        .packet:hover .packet-info {
            opacity: 1;
        }
        .drawing-line {
            position: absolute;
            height: 2px;
            background-color: #3498db;
            transform-origin: left center;
            transform: scaleX(0);
            transition: transform 1.5s ease;
            z-index: 5;
        }
        .drawing-line.active {
            transform: scaleX(1);
        }
        .drawing-line.syn {
            background-color: #1976d2;
        }
        .drawing-line.syn-ack {
            background-color: #388e3c;
        }
        .drawing-line.ack {
            background-color: #ffa000;
        }
        .drawing-line.lost {
            background-color: #e53935;
        }
        .param-group {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .param-group h3 {
            margin-top: 0;
            color: #3498db;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        input[type="range"], select {
            width: 100%;
            margin-bottom: 5px;
            padding: 5px;
        }
        .value-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #7f8c8d;
        }
        .param-description {
            font-size: 0.85em;
            color: #666;
            margin-top: 8px;
            line-height: 1.4;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.secondary {
            background-color: #95a5a6;
        }
        button.secondary:hover {
            background-color: #7f8c8d;
        }
        .step-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .concept-section {
            margin-top: 30px;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .concept-card {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .data-table th {
            background-color: #f2f2f2;
        }
        .data-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .data-table tr.highlight {
            background-color: #e8f4fc;
        }
        .data-table tr.error {
            background-color: #ffebee;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8em;
            font-weight: normal;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .error-message {
            color: #e53935;
            font-weight: bold;
            margin-top: 10px;
        }
        .warning-message {
            color: #ffa000;
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>TCP 三次握手交互式模拟器（含异常场景）</h1>
    <p>通过这个交互式工具，直观理解TCP三次握手的过程，包括正常流程和常见异常情况。</p>
    
    <div class="container">
        <div class="control-panel">
            <h2>控制面板</h2>
            
            <div class="param-group">
                <h3>模拟参数</h3>
                
                <label for="clientISN">
                    客户端初始序列号 (ISN)
                    <span class="tooltip">?
                        <span class="tooltiptext">TCP连接中客户端选择的随机初始序列号</span>
                    </span>
                </label>
                <input type="range" id="clientISN" min="1000" max="50000" value="12345" step="1">
                <div class="value-display">
                    <span>1000</span>
                    <span id="clientISNValue">12345</span>
                    <span>50000</span>
                </div>
                
                <label for="serverISN">
                    服务端初始序列号 (ISN)
                    <span class="tooltip">?
                        <span class="tooltiptext">TCP连接中服务端选择的随机初始序列号</span>
                    </span>
                </label>
                <input type="range" id="serverISN" min="1000" max="50000" value="54321" step="1">
                <div class="value-display">
                    <span>1000</span>
                    <span id="serverISNValue">54321</span>
                    <span>50000</span>
                </div>
            </div>
            
            <div class="param-group">
                <h3>异常场景模拟</h3>
                
                <label for="abnormalScenario">
                    选择异常场景
                    <span class="tooltip">?
                        <span class="tooltiptext">选择要模拟的异常握手场景</span>
                    </span>
                </label>
                <select id="abnormalScenario">
                    <option value="none">正常三次握手</option>
                    <option value="twoWay">两次握手弊端</option>
                    <option value="lostSynAck">SYN-ACK丢失</option>
                    <option value="lostAck">ACK丢失</option>
                </select>
                
                <div class="param-description">
                    注意：异常场景模拟将展示TCP协议设计中的关键考虑。
                </div>
            </div>
            
            <div class="step-controls">
                <button id="startSimulation">开始模拟</button>
                <button id="stepSimulation" class="secondary">单步执行</button>
                <button id="resetSimulation" class="secondary">重置</button>
            </div>
            
            <div id="errorMessage" class="error-message"></div>
            <div id="warningMessage" class="warning-message"></div>
        </div>
        
        <div class="visualization">
            <h2>TCP握手过程可视化</h2>
            
            <div class="handshake-diagram" id="handshakeDiagram">
                <div class="connection-line"></div>
                <div class="client-box">
                    <strong>客户端</strong>
                    <div class="status-indicator" id="clientStatus">状态: CLOSED</div>
                    <div id="clientSeq">序列号: -</div>
                    <div id="clientAck">确认号: -</div>
                </div>
                <div class="server-box">
                    <strong>服务端</strong>
                    <div class="status-indicator" id="serverStatus">状态: CLOSED</div>
                    <div id="serverSeq">序列号: -</div>
                    <div id="serverAck">确认号: -</div>
                </div>
                <!-- 动态添加的绘制线条和数据包 -->
            </div>
            
            <h3>握手过程详情</h3>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>步骤</th>
                        <th>数据包</th>
                        <th>方向</th>
                        <th>序列号</th>
                        <th>确认号</th>
                        <th>状态变化</th>
                        <th>说明</th>
                    </tr>
                </thead>
                <tbody id="handshakeTableBody">
                    <!-- 数据将通过JavaScript动态填充 -->
                </tbody>
            </table>
        </div>
    </div>
    
    <div class="concept-section">
        <h2>TCP握手异常场景解析</h2>
        
        <div class="concept-card">
            <h3>两次握手弊端</h3>
            <p>如果只有两次握手（客户端SYN → 服务端SYN-ACK）：</p>
            <ul>
                <li><strong>服务端无法确认客户端是否收到SYN-ACK</strong>：客户端可能没有收到SYN-ACK，但服务端已经认为连接建立</li>
                <li><strong>资源浪费</strong>：服务端会为半连接分配资源，容易遭受资源耗尽攻击</li>
                <li><strong>历史连接问题</strong>：延迟的SYN包可能导致服务端错误建立连接</li>
            </ul>
        </div>
        
        <div class="concept-card">
            <h3>SYN-ACK丢失</h3>
            <p>当服务端的SYN-ACK包丢失时：</p>
            <ul>
                <li>客户端会等待ACK超时（默认约3秒）</li>
                <li>客户端会重传SYN包（默认重试5次）</li>
                <li>服务端在收到重传的SYN后会再次发送SYN-ACK</li>
                <li>如果始终无法收到SYN-ACK，客户端最终会放弃连接</li>
            </ul>
        </div>
        
        <div class="concept-card">
            <h3>ACK丢失</h3>
            <p>当客户端的ACK包丢失时：</p>
            <ul>
                <li>服务端会等待ACK超时（默认约1分钟）</li>
                <li>服务端会重传SYN-ACK包（默认重试5次）</li>
                <li>客户端已经建立连接，但服务端会关闭连接</li>
                <li>应用程序需要处理这种状态不一致的情况</li>
            </ul>
        </div>
    </div>

    <script>
        // 获取DOM元素
        const clientISNSlider = document.getElementById('clientISN');
        const serverISNSlider = document.getElementById('serverISN');
        const abnormalScenarioSelect = document.getElementById('abnormalScenario');
        
        const clientISNValue = document.getElementById('clientISNValue');
        const serverISNValue = document.getElementById('serverISNValue');
        
        const startBtn = document.getElementById('startSimulation');
        const stepBtn = document.getElementById('stepSimulation');
        const resetBtn = document.getElementById('resetSimulation');
        
        const handshakeDiagram = document.getElementById('handshakeDiagram');
        const clientStatus = document.getElementById('clientStatus');
        const serverStatus = document.getElementById('serverStatus');
        const clientSeq = document.getElementById('clientSeq');
        const clientAck = document.getElementById('clientAck');
        const serverSeq = document.getElementById('serverSeq');
        const serverAck = document.getElementById('serverAck');
        
        const handshakeTableBody = document.getElementById('handshakeTableBody');
        const errorMessage = document.getElementById('errorMessage');
        const warningMessage = document.getElementById('warningMessage');
        
        // 模拟状态
        let simulationState = {
            step: 0,
            clientState: 'CLOSED',
            serverState: 'CLOSED',
            clientISN: 12345,
            serverISN: 54321,
            clientSeqNum: 0,
            serverSeqNum: 0,
            clientAckNum: 0,
            serverAckNum: 0,
            packets: [],
            drawingLines: [],
            abnormalScenario: 'none',
            simulationInterval: null,
            isPacketLost: false
        };
        
        // 更新显示的值
        function updateDisplayValues() {
            clientISNValue.textContent = clientISNSlider.value;
            serverISNValue.textContent = serverISNSlider.value;
        }
        
        // 监听滑块变化
        clientISNSlider.addEventListener('input', updateDisplayValues);
        serverISNSlider.addEventListener('input', updateDisplayValues);
        
        // 初始化显示值
        updateDisplayValues();
        
        // 绘制握手过程
        function drawHandshake() {
            // 清空图表
            const existingPackets = document.querySelectorAll('.packet');
            existingPackets.forEach(packet => packet.remove());
            
            const existingLines = document.querySelectorAll('.drawing-line');
            existingLines.forEach(line => line.remove());
            
            // 更新状态显示
            clientStatus.textContent = `状态: ${simulationState.clientState}`;
            serverStatus.textContent = `状态: ${simulationState.serverState}`;
            clientSeq.textContent = `序列号: ${simulationState.clientSeqNum || '-'}`;
            clientAck.textContent = `确认号: ${simulationState.clientAckNum || '-'}`;
            serverSeq.textContent = `序列号: ${simulationState.serverSeqNum || '-'}`;
            serverAck.textContent = `确认号: ${simulationState.serverAckNum || '-'}`;
            
            // 获取客户端和服务端位置
            const clientRect = document.querySelector('.client-box').getBoundingClientRect();
            const serverRect = document.querySelector('.server-box').getBoundingClientRect();
            const diagramRect = handshakeDiagram.getBoundingClientRect();
            
            const clientCenter = {
                x: clientRect.left + clientRect.width - diagramRect.left,
                y: clientRect.top + clientRect.height/2 - diagramRect.top
            };
            
            const serverCenter = {
                x: serverRect.left - diagramRect.left,
                y: serverRect.top + serverRect.height/2 - diagramRect.top
            };
            
            // 绘制数据包和动画线条
            simulationState.packets.forEach((packet, index) => {
                const lineLength = Math.abs(serverCenter.x - clientCenter.x);
                const lineTop = clientCenter.y + (index * 40) - 15;
                
                // 创建动画线条
                const line = document.createElement('div');
                line.className = `drawing-line ${packet.type}`;
                line.style.width = `${lineLength}px`;
                line.style.top = `${lineTop}px`;
                
                if (packet.direction === 'client-to-server') {
                    line.style.left = `${clientCenter.x}px`;
                    line.style.backgroundColor = '#1976d2';
                } else {
                    line.style.left = `${serverCenter.x - lineLength}px`;
                    line.style.backgroundColor = '#388e3c';
                }
                
                if (packet.isLost) {
                    line.classList.add('lost');
                }
                
                handshakeDiagram.appendChild(line);
                
                // 创建数据包
                const packetElement = document.createElement('div');
                packetElement.className = `packet ${packet.type} ${packet.isLost ? 'lost' : ''}`;
                packetElement.textContent = packet.label;
                
                // 添加数据包详细信息
                const packetInfo = document.createElement('div');
                packetInfo.className = 'packet-info';
                packetInfo.innerHTML = `
                    <div>seq=${packet.seq}</div>
                    <div>ack=${packet.ack}</div>
                    <div>${packet.flags}</div>
                    ${packet.isLost ? '<div style="color:red">(丢失)</div>' : ''}
                `;
                packetElement.appendChild(packetInfo);
                
                // 设置初始位置
                if (packet.direction === 'client-to-server') {
                    packetElement.style.left = `${clientCenter.x}px`;
                    packetElement.style.top = `${lineTop}px`;
                } else {
                    packetElement.style.left = `${serverCenter.x - 80}px`;
                    packetElement.style.top = `${lineTop}px`;
                }
                
                handshakeDiagram.appendChild(packetElement);
                
                // 动画效果
                setTimeout(() => {
                    line.classList.add('active');
                    
                    setTimeout(() => {
                        if (packet.direction === 'client-to-server' && !packet.isLost) {
                            packetElement.style.left = `${serverCenter.x - 80}px`;
                        } else if (packet.direction === 'server-to-client' && !packet.isLost) {
                            packetElement.style.left = `${clientCenter.x}px`;
                        }
                    }, 100);
                }, index * 500);
            });
            
            // 更新表格
            updateHandshakeTable();
        }
        
        // 更新握手表格（修复版）
        function updateHandshakeTable() {
            handshakeTableBody.innerHTML = '';
            errorMessage.textContent = '';
            warningMessage.textContent = '';

            // 基础步骤定义
            const baseSteps = [
                {
                    step: 1,
                    packet: 'SYN',
                    direction: '客户端 → 服务端',
                    seq: simulationState.clientISN,
                    ack: 0,
                    clientState: 'SYN_SENT',
                    serverState: 'LISTEN',
                    description: '客户端发送SYN包，包含初始序列号(ISN)'
                },
                {
                    step: 2,
                    packet: 'SYN-ACK',
                    direction: '服务端 → 客户端',
                    seq: simulationState.serverISN,
                    ack: simulationState.clientISN + 1,
                    clientState: 'SYN_SENT',
                    serverState: 'SYN_RECEIVED',
                    description: '服务端回应SYN-ACK包，包含自己的ISN和对客户端ISN的确认'
                },
                {
                    step: 3,
                    packet: 'ACK',
                    direction: '客户端 → 服务端',
                    seq: simulationState.clientISN + 1,
                    ack: simulationState.serverISN + 1,
                    clientState: 'ESTABLISHED',
                    serverState: 'SYN_RECEIVED',
                    description: '客户端发送ACK包确认服务端的ISN'
                },
                {
                    step: 4,
                    packet: '-',
                    direction: '-',
                    seq: '-',
                    ack: '-',
                    clientState: 'ESTABLISHED',
                    serverState: 'ESTABLISHED',
                    description: '连接建立完成，双方可以开始数据传输'
                }
            ];

            // 根据当前步骤和异常场景生成展示步骤
            let showSteps = [];
            const currentStep = simulationState.step;
            const scenario = simulationState.abnormalScenario;

            // 正常三次握手流程
            if (scenario === 'none') {
                showSteps = baseSteps.slice(0, currentStep + 1);
            } 
            // 两次握手弊端
            else if (scenario === 'twoWay') {
                if (currentStep >= 1) {
                    showSteps.push(baseSteps[0]);
                }
                if (currentStep >= 2) {
                    showSteps.push({
                        ...baseSteps[1],
                        description: '服务端回应SYN-ACK后，没有收到客户端的ACK确认'
                    });
                }
                if (currentStep >= 3) {
                    showSteps.push({
                        step: 3,
                        packet: '-',
                        direction: '-',
                        seq: '-',
                        ack: '-',
                        clientState: 'ESTABLISHED',
                        serverState: 'ESTABLISHED',
                        description: '异常：只有两次握手，服务端无法确认客户端已收到SYN-ACK'
                    });
                    warningMessage.textContent = '警告：两次握手导致服务端无法确认客户端是否收到SYN-ACK，可能出现连接状态不一致';
                }
            } 
            // SYN-ACK丢失场景
            else if (scenario === 'lostSynAck') {
                if (currentStep >= 1) {
                    showSteps.push(baseSteps[0]);
                }
                if (currentStep >= 2) {
                    showSteps.push({
                        ...baseSteps[1],
                        packet: 'SYN-ACK (丢失)',
                        description: '异常：SYN-ACK包丢失，客户端将超时重传SYN'
                    });
                }
                if (currentStep >= 3) {
                    showSteps.push({
                        step: 3,
                        packet: 'SYN (重传)',
                        direction: '客户端 → 服务端',
                        seq: simulationState.clientISN,
                        ack: 0,
                        clientState: 'SYN_SENT',
                        serverState: 'LISTEN',
                        description: '客户端超时未收到SYN-ACK，重传SYN包'
                    });
                    errorMessage.textContent = '错误：SYN-ACK包丢失，连接无法正常建立，客户端将重试';
                }
            } 
            // ACK丢失场景
            else if (scenario === 'lostAck') {
                if (currentStep >= 1) {
                    showSteps.push(baseSteps[0]);
                }
                if (currentStep >= 2) {
                    showSteps.push(baseSteps[1]);
                }
                if (currentStep >= 3) {
                    showSteps.push({
                        ...baseSteps[2],
                        packet: 'ACK (丢失)',
                        description: '异常：ACK包丢失，服务端将超时重传SYN-ACK'
                    });
                }
                if (currentStep >= 4) {
                    showSteps.push({
                        step: 4,
                        packet: 'SYN-ACK (重传)',
                        direction: '服务端 → 客户端',
                        seq: simulationState.serverISN,
                        ack: simulationState.clientISN + 1,
                        clientState: 'ESTABLISHED',
                        serverState: 'SYN_RECEIVED',
                        description: '服务端超时未收到ACK，重传SYN-ACK包'
                    });
                    warningMessage.textContent = '警告：ACK包丢失，客户端认为连接已建立，但服务端将超时关闭连接';
                }
            }

            // 渲染表格
            showSteps.forEach((step, index) => {
                const row = document.createElement('tr');
                
                // 标记异常步骤
                if (
                    (scenario === 'lostSynAck' && step.packet === 'SYN-ACK (丢失)') ||
                    (scenario === 'lostAck' && step.packet === 'ACK (丢失)') ||
                    (scenario === 'twoWay' && step.description.includes('异常'))
                ) {
                    row.classList.add('error');
                }
                // 高亮当前步骤
                else if (index === currentStep - 1) {
                    row.classList.add('highlight');
                }

                row.innerHTML = `
                    <td>${step.step}</td>
                    <td>${step.packet}</td>
                    <td>${step.direction}</td>
                    <td>${step.seq}</td>
                    <td>${step.ack}</td>
                    <td>客户端: ${step.clientState}<br>服务端: ${step.serverState}</td>
                    <td>${step.description}</td>
                `;
                
                handshakeTableBody.appendChild(row);
            });
        }

        // 执行单步模拟
        function simulateStep() {
            if (simulationState.step >= 4) return;
            
            simulationState.step++;
            
            // 获取当前参数
            simulationState.clientISN = parseInt(clientISNSlider.value);
            simulationState.serverISN = parseInt(serverISNSlider.value);
            simulationState.abnormalScenario = abnormalScenarioSelect.value;
            
            // 根据步骤更新状态
            switch(simulationState.step) {
                case 1: // 第一步：客户端发送SYN
                    simulationState.clientState = 'SYN_SENT';
                    simulationState.serverState = 'LISTEN';
                    simulationState.clientSeqNum = simulationState.clientISN;
                    
                    simulationState.packets = [{
                        type: 'syn',
                        label: 'SYN',
                        seq: simulationState.clientISN,
                        ack: 0,
                        direction: 'client-to-server',
                        flags: 'SYN=1',
                        isLost: false
                    }];
                    break;
                    
                case 2: // 第二步：服务端发送SYN-ACK
                    simulationState.serverState = 'SYN_RECEIVED';
                    simulationState.serverSeqNum = simulationState.serverISN;
                    simulationState.serverAckNum = simulationState.clientISN + 1;
                    
                    // 检查是否是SYN-ACK丢失场景
                    const isSynAckLost = simulationState.abnormalScenario === 'lostSynAck';
                    
                    simulationState.packets.push({
                        type: 'syn-ack',
                        label: isSynAckLost ? 'SYN-ACK (丢失)' : 'SYN-ACK',
                        seq: simulationState.serverISN,
                        ack: simulationState.clientISN + 1,
                        direction: 'server-to-client',
                        flags: 'SYN=1, ACK=1',
                        isLost: isSynAckLost
                    });
                    break;
                    
                case 3: // 第三步：客户端发送ACK
                    simulationState.clientState = 'ESTABLISHED';
                    simulationState.clientAckNum = simulationState.serverISN + 1;
                    
                    // 检查是否是ACK丢失场景
                    const isAckLost = simulationState.abnormalScenario === 'lostAck';
                    
                    simulationState.packets.push({
                        type: 'ack',
                        label: isAckLost ? 'ACK (丢失)' : 'ACK',
                        seq: simulationState.clientISN + 1,
                        ack: simulationState.serverISN + 1,
                        direction: 'client-to-server',
                        flags: 'ACK=1',
                        isLost: isAckLost
                    });
                    break;
                    
                case 4: // 第四步：连接建立完成
                    if (simulationState.abnormalScenario === 'twoWay') {
                        // 两次握手场景，服务端也认为连接建立
                        simulationState.serverState = 'ESTABLISHED';
                    } 
                    else if (simulationState.abnormalScenario === 'lostAck') {
                        // ACK丢失场景，服务端会超时关闭连接
                        simulationState.serverState = 'CLOSED';
                    }
                    else {
                        // 正常情况，服务端收到ACK后建立连接
                        simulationState.serverState = 'ESTABLISHED';
                    }
                    break;
            }
            
            // 处理两次握手异常场景
            if (simulationState.abnormalScenario === 'twoWay' && simulationState.step === 3) {
                simulationState.step = 4; // 跳过第三步
                simulationState.clientState = 'ESTABLISHED';
                simulationState.serverState = 'ESTABLISHED';
            }
            
            drawHandshake();
        }
        
        // 开始模拟
        function startSimulation() {
            resetSimulation();
            
            simulationState.simulationInterval = setInterval(() => {
                simulateStep();
                
                if (simulationState.step >= 4) {
                    stopSimulation();
                }
            }, 1500);
        }
        
        // 停止模拟
        function stopSimulation() {
            if (simulationState.simulationInterval) {
                clearInterval(simulationState.simulationInterval);
                simulationState.simulationInterval = null;
            }
        }
        
        // 重置模拟
        function resetSimulation() {
            stopSimulation();
            
            simulationState = {
                step: 0,
                clientState: 'CLOSED',
                serverState: 'CLOSED',
                clientISN: parseInt(clientISNSlider.value),
                serverISN: parseInt(serverISNSlider.value),
                clientSeqNum: 0,
                serverSeqNum: 0,
                clientAckNum: 0,
                serverAckNum: 0,
                packets: [],
                drawingLines: [],
                abnormalScenario: abnormalScenarioSelect.value,
                simulationInterval: null,
                isPacketLost: false
            };
            
            drawHandshake();
        }
        
        // 事件监听
        startBtn.addEventListener('click', startSimulation);
        stepBtn.addEventListener('click', simulateStep);
        resetBtn.addEventListener('click', resetSimulation);
        
        // 初始绘制
        resetSimulation();
    </script>
</body>
</html>